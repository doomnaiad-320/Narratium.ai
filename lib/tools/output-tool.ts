import { ChatPromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { v4 as uuidv4 } from "uuid";
import { BaseTool } from "./base-tool";
import { ToolType, ToolExecutionContext, ToolExecutionResult, PlanTask } from "@/lib/models/agent-model";
import { ResultOperations } from "@/lib/data/agent/result-operations";

/**
 * Output Tool - Generate character and worldbook content
 */
export class OutputTool extends BaseTool {
  readonly toolType = ToolType.OUTPUT;
  readonly name = "Content Generator";
  readonly description = "Generate character data and worldbook entries";

  async executeTask(task: PlanTask, context: ToolExecutionContext): Promise<ToolExecutionResult> {
    const type = task.parameters.type;
    
    if (type === "character") {
      return await this.generateCharacter(task, context);
    } else if (type === "worldbook") {
      return await this.generateWorldbook(task, context);
    }

    return {
      success: false,
      error: "Unknown output type",
      should_continue: true,
    };
  }

  private async generateCharacter(task: PlanTask, context: ToolExecutionContext): Promise<ToolExecutionResult> {
    await this.addThought(context.conversation_id, "reasoning", "Generating character data based on requirements", task.id);
    
    // Use LLM to generate character data
    const llm = this.createLLM(context.llm_config);
    
    const prompt = ChatPromptTemplate.fromMessages([
      ["system", "You are an expert character creator. Generate a detailed character based on the user's requirements. Return as JSON with fields: name, description, personality, scenario, first_mes, mes_example, creator_notes. Make the character interesting, unique, and engaging for roleplay."],
      ["human", `User request: ${context.plan_pool.context.user_request}\n\nGenerate a character that fits this request. Be creative and detailed.`],
    ]);

    try {
      const chain = prompt.pipe(llm).pipe(new StringOutputParser());
      const response = await chain.invoke({});
      const characterData = JSON.parse(response);
      
      // Ensure required fields exist
      const completeCharacterData = {
        name: characterData.name || "Generated Character",
        description: characterData.description || "",
        personality: characterData.personality || "",
        scenario: characterData.scenario || "",
        first_mes: characterData.first_mes || `Hello, I'm ${characterData.name || "your character"}.`,
        mes_example: characterData.mes_example || "",
        creator_notes: characterData.creator_notes || "Generated by AI Agent",
        avatar: "",
        alternate_greetings: characterData.alternate_greetings || [],
        tags: characterData.tags || [],
      };
      
      await ResultOperations.updateCharacterData(context.conversation_id, completeCharacterData);
      
      await this.addMessage(
        context.conversation_id,
        "agent",
        `✅ Generated character: **${completeCharacterData.name}**\n\n${completeCharacterData.description.substring(0, 200)}...`,
      );
      
      return {
        success: true,
        result: completeCharacterData,
        should_continue: true,
      };
    } catch (error) {
      console.error("Character generation failed:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Character generation failed",
        should_continue: true,
      };
    }
  }

  private async generateWorldbook(task: PlanTask, context: ToolExecutionContext): Promise<ToolExecutionResult> {
    await this.addThought(context.conversation_id, "reasoning", "Generating worldbook entries based on character and requirements", task.id);
    
    // Use LLM to generate worldbook entries
    const llm = this.createLLM(context.llm_config);
    
    const characterInfo = context.current_result.character_data ? 
      `Character: ${JSON.stringify(context.current_result.character_data)}` : 
      "No character data available yet";
    
    const prompt = ChatPromptTemplate.fromMessages([
      ["system", "You are an expert worldbuilder. Generate detailed worldbook entries that complement the character and user requirements. Return as JSON array with objects containing: key (array of trigger words), comment (entry title), content (detailed description), constant (boolean), selective (boolean). Create 3-5 entries that build a rich, interconnected world."],
      ["human", `User request: ${context.plan_pool.context.user_request}\n${characterInfo}\n\nGenerate worldbook entries that create an immersive world for this character.`],
    ]);

    try {
      const chain = prompt.pipe(llm).pipe(new StringOutputParser());
      const response = await chain.invoke({});
      const worldbookEntries = JSON.parse(response);
      
      // Format entries properly
      const formattedEntries = worldbookEntries.map((entry: any, index: number) => ({
        id: uuidv4(),
        uid: uuidv4(),
        key: Array.isArray(entry.key) ? entry.key : [entry.key],
        keysecondary: entry.keysecondary || [],
        comment: entry.comment || `Entry ${index + 1}`,
        content: entry.content || "",
        constant: entry.constant || false,
        selective: entry.selective !== false, // Default to true
        order: index,
        position: entry.position || 0,
        disable: false,
        probability: entry.probability || 100,
        useProbability: entry.useProbability || false,
      }));
      
      await ResultOperations.updateWorldbookData(context.conversation_id, formattedEntries);
      
      await this.addMessage(
        context.conversation_id,
        "agent",
        `✅ Generated ${formattedEntries.length} worldbook entries:\n${formattedEntries.map((e: any) => `• ${e.comment}`).join("\n")}`,
      );
      
      return {
        success: true,
        result: formattedEntries,
        should_continue: true,
      };
    } catch (error) {
      console.error("Worldbook generation failed:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Worldbook generation failed",
        should_continue: true,
      };
    }
  }
} 
